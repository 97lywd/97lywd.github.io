---
title: C++入门语法篇
date: 2019-08-23 10:54:28
tags: [C++]
---

## 1.引用
- 引用不是重新定义一个变量，而是为变量取了一个别名，且不重新开辟空间，与引用的实体共享一块空间。
- 引用的特性：定义时必须初始化，一个变量可以有多个引用，但是一个引用只能引用一个实体。`//int &ra 就会编译出错(未初始化)`
<!--more-->
- 引用的用法：

  ``
int a = 10;
int &ra = a;
``
**即类型 &引用对象名 = 引用实体**
- 常引用：**const 类型 & 引用对象名 = 引用实体**
   
```
// eg： const &ra = a；
```
   但是下面这种方法是不对的：
   

```
// const int a = 10;  int &ra = a;
```
显然易见通过ra可以修改a的值

- 与指针的区别：
a.有多级(NULL)指针，但是没有多级(NULL)引用。
b.引用定义时必须初始化，但指针无要求。
c.引用只可引用一个实体，但是指针可以指向多个变量。

## 2.函数重载
- 函数重载的定义：c++允许在同一作用域中声明几个功能类似的同名函数， 
               这些函数的形参列表(参数个数/类型/顺序)必须不一样。
           

```
//eg:
int Add(int right, int left)
{
       return left + right;
}
double Add(double right, double left)
{
       return left + right;
}
```
但是，如果参数列表相同，返回值不同，就不是函数重载，而是函数重定义，这是不被允许的

```
//编译出错
int Add(int left, int right)
	{
		return left + right;
	}
	double Add(int left, int right)
	{
		return left + right;
	}
```

## 3.auto关键字(c++11)
- auto声明的变量必须由编译器在编译时推导
- auto的用法：

```
auto a = 10;
//
//也可以这样：
int a = 10;
auto b = a;
auto c = 'a';
```
- 在定义指针时，auto与auto*无区别，但是定义引用时必须时auto&
``
int a = 10; auto b = &a; auto *b = &a  //等价的
``
- 定义多个变量时，变量类型必须一致

```
 auto a = 10, b =20
 auto a = 10,b = 9.0   //编译错误
```
- auto不能直接用来声明数组
- auto不能作为形参

## 4.基于范围的for循环(c++11)
- 用法：for的括号内容由：分为两部分，一是范围内用于迭代的变量，一是被表示迭代的范围

```
int a[] = { 0,1,2,3,4,5 };
	for (auto e:a)
	{
		cout << e;
	}
```
- 使用条件:

        a.迭代的范围必须是确定的
        b.迭代的对象必须实现++和==操作

## 5.缺省函数
- 缺省函数是定义函数时，为其参数定义的一个默认值，调用该函数时，如果没有指定实参，则采用默认值。

```
void test(int a = 0){}
int main()
{
       test(10)// 传参时，使用指定实参
       test()  //无参数时，将使用默认值0
       return 0;
}
```

- 全缺省参数
``
void test(int a = 10, int b = 20){}
``
- 半缺省参数
``void test(int a,int b = 20){}
``
注意：半缺省参数必须从左到右依次给出，不给间隔着给
- 缺省函数不能同时出现在函数的声明与定义中
