---
title: '动态规划(二): 更为复杂的状态方程'
date: 2019-08-25 15:13:13
tags:
     - Algorithm
     - C++
---
在前面我们谈到了一些简单的用动态规划解决的问题：
[动态规划(一)：从Fibonacci数列谈起](https://blog.csdn.net/weixin_42549259/article/details/97263715)
但是，在DP问题里，我们很多时候对于状态方程的递推，往往更加复杂，我们看以下几道题：

<!--more-->

**A.字符串分割**
题目难度：Medium
题目来源：[牛客网](https://www.nowcoder.com/practice/5f3b7bf611764c8ba7868f3ed40d6b2c?tpId)
题目描述：

*<font color="#00dd00">Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
For example, given
s ="leetcode",
dict =["leet", "code"].
Return true because"leetcode"can be segmented as"leet code".</font>*
          
    1.定义状态:F(i)---第i个字符是否可以被字典中的词分割
    2.状态方程：j<i && dict.find(s.substr(j,i-j)&&F(j)
    3.初始值：F(0) = true
    4.返回值: F(n)
代码如下：

```cpp
class Solution {
public:
    bool wordBreak(string s, unordered_set<string> &dict) {
        if(s.empty())
            return false;
        if(dict.empty())
            return false;
        vector<bool>wb(s.size() + 1,false);
        wb[0] = true;
        for(int i = 1; i <= s.size();i++)
        {
         for(int j = i - 1;j >= 0; j--)
         {
             if(wb[j] && dict.find(s.substr(j,i - j)) != dict.end())
             {
                  wb[i] = true;
                 break;
             }
         }
        }
        return wb[s.size()];
    }
};
```
**B.三角矩阵问题**
题目难度：Medium
题目来源：[牛客网](https://www.nowcoder.com/practice/2b7995aa4f7949d99674d975489cb7da?tpId)
*<font color="#00dd00">Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is11(i.e., 2 + 3 + 5 + 1 = 11).
Note: 
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</font>*

方法一：自顶向下

     1.定义状态：F(i,j)---从(0,0)到(i,j)的最小路径之和
     2.状态方程：min(minsum(i-1)(j-1),(i-1)(j)) + triangle(i)(j)
     3.初始值：F(0)(0) = triangle(0)(0)
     4.返回值：min(F(i - 1)(j))
     
代码如下：

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        if(triangle.empty())
            return 0;
        vector<vector<int>> minsum(triangle);
        int line = triangle.size();
            for(int i = 1; i < line; i++)
            {
               for(int j = 0; j <= i; j++)
               {
                 if(j==0){
                     minsum[i][j] = minsum[i - 1][j];
                 }
                   else if(i == j){
                       minsum[i][j] = minsum[i - 1][j - 1];
                   }
                   else{
                       minsum[i][j] = min(minsum[i - 1][j - 1],minsum[i -1][j]);
                   }
                   minsum[i][j] = minsum[i][j] + triangle[i][j];
               }
            }
        
        int minresult = minsum[line - 1][0];
        for(int i = 1; i < line; i++)
        {
                   minresult = min(minsum[line - 1][i],minresult);
        }
        return minresult;
    }
};
```


方法二：自底向上

    1.定义状态： F(i,j)---(i,j)到最后一行的最小路径和
    2.状态方程：F(i,j) = min(F(i+1)(j+1),(i+1)(j)+triangle[i][j]
    3.初始值：F(n-1)(0) = triangle(n-1,0)
    4.返回值F(0)(0)
代码如下：

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        if(triangle.empty())
            return 0;
        vector<vector<int>> minsum(triangle);
        int line = triangle.size();
        for(int i = line - 2; i >= 0; i--)
        {
            for(int j = 0; j <= i; j++)
            {
               minsum[i][j] = min(minsum[i+1][j],minsum[i+1][j+1]) + triangle[i][j];
            }
        }
        return minsum[0][0];
    }
};
```

除此之外，本题还可以用一维滚动数组来定义状态，但是缺点是，无法记录所有路径。


**C.路径总数问题**
题目难度：Medium
题目来源：[牛客网](https://www.nowcoder.com/practice/3cdf08dd4e974260921b712f0a5c8752?tpId)
题目描述：

*<font color="#00dd00">Follow up for "Unique Paths":
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as1and0respectively in the grid.
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is2.
Note: m and n will be at most 100.*

     1.定义状态：F(i)(j)---(0,0)到(i,j)的路径个数
     2.状态方程：F(i)(j)=F(i-1)(j) + F(i)(j-1)
     3.初始值：F(i)(0) = F(0)(j) = 1 if obstacleGrid(i,j) != 1
     4.返回值：F(m-1)(n-1)
代码如下：

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {
        //F[i][j] = F[i-1][j] + F[i][j-1]
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> uq(m,vector<int>(n,0));
        for(int i = 0; i < n; i++)
        {
            if(obstacleGrid[0][i])
            {
                break;
            }
            else{
                    uq[0][i] = 1;
            }
        }
        for(int i = 0; i < m; i++)
        {
            if(obstacleGrid[i][0])
            {
                break;
            }
            else{
                    uq[i][0] = 1;
            }
        }
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                 if(obstacleGrid[i][j])
                {
                    uq[i][j] = 0;
                }
                else{
                    uq[i][j] = uq[i-1][j] + uq[i][j-1];
                }
            }
        }
        return uq[m-1][n-1];
    }
};
```

