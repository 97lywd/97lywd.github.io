---
title: '动态规划(三): 更为隐蔽的状态推断'
date: 2019-08-25 15:19:13
tags:
    - Algorithm
    - C++
---

前面我们探讨了dp问题的一些常见情况：
[动态规划(一): 从Fibonacci数列谈起](https://blog.csdn.net/weixin_42549259/article/details/97263715)
[动态规划(二):     更为复杂的状态方程](https://blog.csdn.net/weixin_42549259/article/details/97506216)
但是DP问题很多时候初始值，状态，状态方程是非常隐蔽的，我们来看以下几道题：

**A.回文串分割**

题目难度：Hard

题目来源：[牛客网](https://www.nowcoder.com/practice/1025ffc2939547e39e8a38a955de1dd3?tpId)


<!--more-->

题目描述：

*<font color=#00dd00>Given a string s, partition s such that every substring of the partition is a palindrome.
Return the minimum cuts needed for a palindrome partitioning of s.
For example, given s ="aab",
Return1since the palindrome partitioning["aa","b"]could be produced using 1 cut.</font>*

      1.定义状态:F(i)---第i个字符需要的最小分割次数
      2.状态方程:F(i)=min(F(i),1+F(j))
      3.初始值:F(i)=i-1
      4.返回值:F(n)

以"aab"为例，"aab"明显不是回文串
 
 *
* 所以 f("aab") = min( (f("a")+f("ab")) , (f("aa")+f("b")) ) + 1;
* f("a") = 0;
* f("ab") = f("a")+f("b") +1  = 0+0+1 = 1;
* f("aa") = 0;
* f("b") = 0;
* 即f("aab") = 1;
* 
代码如下：

```cpp
class Solution {
public:
    int minCut(string s) {
        if(s.empty())
            return 0;
        int len = s.size();
        vector<int>cut;
        for(int i = 0; i <= len; i++)
        {
              cut.push_back(i-1);
        }
        for(int i = 1; i <= len; i++)
        {
            for(int j = 0; j < i; j++)
            {
                if(Ispalindrome(s,j,i-1))
                {
                    cut[i] = min(cut[i],1 + cut[j]);
                }
            }
        }
        return cut[len];
    }
        bool Ispalindrome(string s,int i, int j)
        {
            while(i<j)
            {
                if(s[i] == s[j]){
                    i++;
                    j--;
                }
                else 
                    return false;
            }
            return true;
        }
    
};
```
**B.编辑距离问题**

题目难度：Hard

题目来源：[牛客网](https://www.nowcoder.com/practice/81d7738f954242e5ade5e65ec40e5027?tpId)

题目描述：
*<font color=#00dd00>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)
You have the following 3 operations permitted on a word:
a) Insert a character
b) Delete a character
c) Replace a character</font>*

      1.定义状态:F(i,j)---word1前i个字符到word2前j个字符所需要的编辑次数
      2.状态方程:F(i,j)=min(1+F(i-1,j),F(i)(j-1),F(i-1)(j-1))
                        +word1==word2?0:1
      3.初始值：F(i,0) = i  F(0,j) = j
      4.返回值：F(word1.size,word.size)

代码如下：

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        if(word1.empty()||word2.empty())
            return max(word1.size(),word2.size());
        int len1 = word1.size();
        int len2 = word2.size();
        vector<vector<int>>dp(1+len1,vector<int>(1+len2,0));
        for(int i = 0; i <=len1; i++)
        {
            for(int j = 0; j <= len2; j++)
            {
                if(i == 0)
                {
                     dp[i][j] = j;
                }
                else if(j == 0)
                {
                      dp[i][j] = i;
                }
               else if(word1[i-1]==word2[j-1]){
                   dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1]);
                   dp[i][j] = min(dp[i][j],dp[i-1][j-1]);
               }
                else{
                    dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1]);
                    dp[i][j] = min(dp[i][j],1 + dp[i-1][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
};
```
**C.不同子序列问题**

题目难度：Hard

题目来源：[牛客网](https://www.nowcoder.com/practice/ed2923e49d3d495f8321aa46ade9f873?tpId)

题目描述：

*<font color=#00dd00>Given a string S and a string T, count the number of distinct subsequences of T in S.
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie,"ACE"is a subsequence of"ABCDE"while"AEC"is not).
Here is an example:
S ="rabbbit", T ="rabbit"
Return3.</font>*

     1.定义状态：F(i,j)---S中第i个字符在T中相同的个数
     2.状态方程：F(i,j)=F(i-1,j-1)+F(i-1,j)   S[i]=T[j]
                  F(i,j)=F(i-1,j)            S[i]!=T[j]
     3.初始值：F(i,0)=1 F(0,0)=1
     4.返回值：F(S.length,T.length)
代码如下：

```cpp
class Solution {
public:
    int numDistinct(string S, string T) {
        int len1 = S.size();
        int len2 = T.size();
        if(len1 < len2)
            return 0;
        if(T.empty());
            return 1;
        vector<vector<int>>dp(1+len1,vector<int>(1+len2,0));
      for(int i = 0;i <= len1;i++)
      {
           dp[i][0]=1;
      }
        for(int i = 1; i <= len1; i++)
        {
             for(int j = 1; j <= len2; j++)
             {
                if(S[i-1] == T[j-1]){
                     dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                 }
                 else{
                     dp[i][j] = dp[i-1][j];
                 }
             }
        }
        return dp[len1][len2];
    }
};
```

